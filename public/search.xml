<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Vue项目中audio元素在移动端无法自动播放的问题]]></title>
    <url>%2F2018%2F03%2F30%2F%E8%A7%A3%E5%86%B3Vue%E9%A1%B9%E7%9B%AE%E4%B8%ADaudio%E5%85%83%E7%B4%A0%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述用 Vue 开发一个 HTML5 活动页面，活动页面需要一个循环播放的背景音乐，一进入页面就自动播放。按照正常思维，直接插入 audio 元素，设置好属性就算完了。就像下面这样： 1&lt;audio src="path/to/music" loop autoplay&gt;&lt;/audio&gt; 这样多简单啊，在 PC 浏览器上也表现正常。拿到手机上测试一下，才发现根本不出声音。问题就来了，为啥在手机上不能自动播放呢。 探索过程使用 google 大法了解到，移动设备为了节省流量，禁用了 audio 元素的自动播放的功能。必须要有用户交互才能播放音频，比如说 touchstart 事件。 了解到这个重要信息，马上也就可以找到相应的解决办法，那就是模拟 touchstart 事件啦，然后把这个事件的触发放到 Vue 的生命周期方法中，比如 mounted。 因此马上就做一个音频播放器的组件 AudioPlayer.vue 的组件，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;template&gt; &lt;div class="player"&gt; &lt;div class="player-cd" id="trigger" &gt; &lt;audio :src="src" id="audio" loop &gt;&lt;/audio&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; src: 'http://o9o8lcfa3.bkt.clouddn.com/%E5%88%9A%E5%A5%BD%E9%81%87%E8%A7%81%E4%BD%A0.m4a' &#125; &#125;, mounted () &#123; let trigger = document.getElementById('trigger') let audio = document.getElementById('audio') trigger.addEventListener('touchstart', () =&gt; &#123; audio.play() &#125;) // 模拟触发 「touchstart」 事件 this.createTouchstartEventAndDispatch(trigger) &#125;, methods: &#123; createTouchstartEventAndDispatch (el) &#123; let event = document.createEvent('Events') event.initEvent('touchstart', true, true) el.dispatchEvent(event) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;// var@cdWidth: 50vmin;// mixins// 水平垂直居中的 flex 布局.flex-align-justify-center &#123; display: flex; align-items: center; justify-content: center;&#125;// 直径为 width 的圆.circle (@width) &#123; width: @width; height: @width; border-radius: 50%;&#125;// block 伪类.absolute-block &#123; content: ''; display: block; position: absolute;&#125;.player &#123; .flex-align-justify-center; width: 100vw; height: 100vh; &amp;-cd &#123; .flex-align-justify-center; .circle(@cdWidth); background: linear-gradient(#666, #000); .absolute-circle-block (@color, @width) &#123; .absolute-block; .circle(@width); background: @color; &#125; &amp;::before &#123; .absolute-circle-block(darken(#f00, 5%), 20vmin); &#125; &amp;::after &#123; .absolute-circle-block(#222, 5vmin); &#125; &#125;&#125;&lt;/style&gt; 去浏览器预览的时候发现，上面的代码在 PC 和 Android 手机上和预期一样，可以自动播放。但是在 iOS 上依然不行。通过更进一步的了解，发现在微信内置浏览器内有一种解决办法，利用的是微信内置浏览器的事件 WeixinJSBridgeReady。具体实现见下一小节。 解决方法（不彻底）目前自动播放功能实现情况如下： 平台 系统自带浏览器 微信内置浏览器 PC ✔️ ✔️ Android ✔️ ✔️ iOS ✔️ ✔️ 在实现上述功能的基础上，增加播放旋转，点击切换播放、暂停功能。最终组件代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;template&gt; &lt;div class="player"&gt; &lt;div class="player-cd" id="trigger" :style="&#123;transform: 'rotate(' + transformValue + 'deg)'&#125;" &gt; &lt;audio :src="src" id="audio" loop &gt;&lt;/audio&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; src: 'http://o9o8lcfa3.bkt.clouddn.com/%E5%88%9A%E5%A5%BD%E9%81%87%E8%A7%81%E4%BD%A0.m4a', playing: false, transformValue: 10, transformInterval: null &#125; &#125;, mounted () &#123; let trigger = document.getElementById('trigger') let audio = document.getElementById('audio') trigger.addEventListener('touchstart', () =&gt; &#123; audio.play() this.togglePlay() &#125;) // 单独处理微信内置浏览器自动播放 document.addEventListener('WeixinJSBridgeReady', () =&gt; &#123; audio.play() &#125;, false) // 模拟触发 「touchstart」 事件 this.createTouchstartEventAndDispatch(trigger) &#125;, methods: &#123; createTouchstartEventAndDispatch (el) &#123; let event = document.createEvent('Events') event.initEvent('touchstart', true, true) el.dispatchEvent(event) &#125;, togglePlay () &#123; this.playing = !this.playing if (this.playing) &#123; this.transformInterval = setInterval( () =&gt; this.changeTransformValue(), 100 ) &#125; else &#123; clearInterval(this.transformInterval) this.transformInterval = null &#125; &#125;, changeTransformValue () &#123; this.transformValue += 10 &#125; &#125;, watch: &#123; playing (playing) &#123; let audio = document.getElementById('audio') if (playing) &#123; audio.play() &#125; else &#123; audio.pause() &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;// var@cdWidth: 50vmin;// mixins// 水平垂直居中的 flex 布局.flex-align-justify-center &#123; display: flex; align-items: center; justify-content: center;&#125;// 直径为 width 的圆.circle (@width) &#123; width: @width; height: @width; border-radius: 50%;&#125;// block 伪类.absolute-block &#123; content: ''; display: block; position: absolute;&#125;.player &#123; .flex-align-justify-center; width: 100vw; height: 100vh; &amp;-cd &#123; .flex-align-justify-center; .circle(@cdWidth); background: linear-gradient(#666, #000); transition: all .2s linear; .absolute-circle-block (@color, @width) &#123; .absolute-block; .circle(@width); background: @color; &#125; &amp;::before &#123; .absolute-circle-block(darken(#f00, 5%), 20vmin); &#125; &amp;::after &#123; .absolute-circle-block(#222, 5vmin); &#125; &#125;&#125;&lt;/style&gt; 附上线上预览地址]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>audio</tag>
        <tag>HTML5</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习React（二）]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%AD%A6%E4%B9%A0React%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ComponentsReact 组件分为函数式组件（Functional Components） 和类式组件（Class Components）。从字面意思可以看出来，组件可以写成函数形式，也可以写成类的形式。 Functional Componentsindex.js 文件内容： 1234567891011import React from 'react'import ReactDom from 'react-dom'function Welcome (props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;&#125;ReactDom.render( &lt;Welcome name="John" /&gt;, document.getElementById('root')) Class Componentsindex.js 文件内容： 12345678910111213import React from 'react'import ReactDom from 'react-dom'class Welcome extends React.Component &#123; constructor () &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125;ReactDom.render( &lt;Welcome name="John" /&gt;, document.getElementById('root')) index.html 文件内容： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;React Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Functional Components 和 Class Components 可以混用，本质上都是传入只读的 props 对象，保证数据的单向流动，React 根据 props 对象传入的内容更新渲染 DOM。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决SecureCRT无法保存密码的问题]]></title>
    <url>%2F2018%2F03%2F28%2F%E8%A7%A3%E5%86%B3SecureCRT%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题在 SecureCRT 上登录同一台机器，每次都要输入密码，非常繁琐。登录的时候「保存密码」的选项又是勾上的，就是不起作用，怎么办呢？ 方法打开 secureCRT =&gt; Preferences，左侧选择 General，去掉右侧面板中 Use Keychain 选项，如下图： 然后登录的时候确保「保存密码」 选项选中的情况下，成功登录一次之后，密码就会保存下来了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SecureCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习React（一）]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%AD%A6%E4%B9%A0React%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景随着了解的使用 React 大法的项目慢慢变多，渐渐产生了兴趣，想要从头好好看看 React。因此就有了这个起手式。 Hello World12345678910111213141516171819202122232425262728# 新建目录mkdir demo# 初始化yarn init -y# 安装 react、react-domyarn add react react-dom# 新建入口文件touch index.js# 编辑入口文件vim index.js# 新建 index.htmltouch index.html# 编辑 index.htmlvim index.html# 全局安装 parcel，如果已经安装可以跳过npm i -g parcel# 启动项目parcel index.html# 在浏览器中打开 http://localhost:1234 预览 index.js 文件的内容： 1234567import React from 'react'import ReactDom from 'react-dom'ReactDom.render( &lt;h1&gt;Hello World&lt;/h1&gt;, document.getElementById('root')) index.html 文件内容： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;React Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-二分查找]]></title>
    <url>%2F2017%2F12%2F05%2Fpython-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[常见简单算法之 – 二分查找 123456789101112131415161718192021def binary_search(list, item): low = 0 high = len(list) - 1 while low &lt;= high: mid = int((low + high) / 2) guess = list[mid] if guess == item: return mid if guess &gt; item: high = mid - 1 else: low = mid + 1 return None # test casetest_list = [1, 3, 5, 7, 9]print(binary_search(test_list, 5))print(binary_search(test_list, -1))]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>python</tag>
        <tag>binary_search</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS防御]]></title>
    <url>%2F2017%2F11%2F24%2FXSS%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[XSS 攻击是一个很大的 Web 安全问题。XSS 攻击无处不在，但是到目前为止没有一套简单成熟的防御机制。 XSS 攻击 存储型 XSS 反射型 XSS DOM XSS XSS 防御 data type context code example defend method String HTML Body &lt;span&gt;UNTRUSTED DATA&lt;/span&gt; HTML Entity 编码 String 安全 HTML 变量 &lt;input type=&quot;text&quot; name=&quot;fname&quot; value=&quot;UNTRUSTED DATA&quot;&gt; 1. HTML Attribute 编码 2. 只把不可信数据放在安全白名单内的变量上 3. 严格地校验不安全变量，如 background、id 和 name String GET 参数 &lt;a href=&quot;/site/search?value=UNTRUSTED DATA&quot;&gt;clickme&lt;/a&gt; URL 编码 String 使用在 src 或 href 变量上的不可信 URLs &lt;a href=&quot;UNTRUSTED URL&quot;&gt;clickme&lt;/a&gt; &lt;iframe src=&quot;UNTRUSTED URL&quot;&gt; 1. 对输入进行规范化 2. URL 校验 3. URL 安全性认证 4. 只允许使用 http 和 https 协议（避免使用 javscript 协议去打开一个新窗口） 5. HTML Attribute 编码 String CSS 值 &lt;div style=&quot;width: UNTRUSTED DATA;&quot;&gt;Selection&lt;/div&gt; 1. 使用 CSS 编码 2. 使用 CSS Hex 编码 3. 良好的 CSS 设计 String javascript 变量 &lt;script&gt;var currentValue=&#39;UNTRUSTED DATA&#39;;&lt;/script&gt;&lt;scrip&gt;someFunction(&#39;UNTRUSTED DATA&#39;);&lt;/script&gt; 1. 确保所有变量值都被引号括起来 2. 使用 javascript Hex 编码 3. 使用 javascript Unicode 编码 4. 避免使用反斜杠转义（\”, \’ 或者 \） HTML HTML Body &lt;div&gt;UNTRUSTED HTML&lt;/div&gt; HTML 校验（JSoup, AntiSamy, HTML Sanitizer） String DOM XSS &lt;script&gt;document.write(&#39;UNTRUSTED INPUT: &#39;+window.location.hash);&lt;/script&gt; 基于 DOM 操作的 XSS 漏洞防御措施]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理的Express如何拿到真实客户端IP]]></title>
    <url>%2F2017%2F10%2F27%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84Express%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E7%9C%9F%E5%AE%9E%E5%AE%A2%E6%88%B7%E7%AB%AFIP%2F</url>
    <content type="text"><![CDATA[最近碰到一个苦恼的问题，Express 的后端打印客户端的真实 IP 地址，结果打印出来的全部是127.0.0.1。如果你也碰到了这个问题，那么恭喜你，我接下来就告诉你怎么解决。 正常来说，引起这个问题的原因就是服务器做了 nginx 反向代理。所有客户端的请求都先打到 nginx 服务器，然后 nginx 服务器再去请求 node 服务器，如果 nginx 和 node 服务器部署在同一台机上面，那么 node 能拿到的 IP 地址其实就是本机地址，也就是127.0.0.1。 找到引起问题的根源，就可以对症下药了。 修改 nginx 配置配置修改如下： 1234567891011121314server &#123; listen 80; server_name website.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Proto https; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Host $remote_addr; proxy_pass http://127.0.0.1:3000/; &#125;&#125; 修改 Express 配置修改 app.js 文件，增加一行代码： 1app.set('trust proxy', 'loopback'); 获取客户端真实 IP 地址在代码中使用req.ip就可以获取到用户的真实 IP 地址了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>Express</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下SVN账号密码保存方法]]></title>
    <url>%2F2017%2F10%2F18%2FLinux%E4%B8%8BSVN%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E4%BF%9D%E5%AD%98%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Linux下进行SVN操作的时候总是提示要输入密码，很不方便，尤其是集成到npm scripts上的时候，你不想明写密码，但是如果不写，每次都提示要输入密码，不同用户协作起来更加麻烦。 修改配置文件config文件位置/home/[username]/.subversion/config 用vim打开 1vim /home/[username]/.subversion/config 原配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186### This file configures various client-side behaviors.###### The commented-out examples below are intended to demonstrate### how to use this file.### Section for authentication and authorization customizations.[auth]### Set password stores used by Subversion. They should be### delimited by spaces or commas. The order of values determines### the order in which password stores are used.### Valid password stores:### gnome-keyring (Unix-like systems)### kwallet (Unix-like systems)### gpg-agent (Unix-like systems)### keychain (Mac OS X)### windows-cryptoapi (Windows)# password-stores = gpg-agent,gnome-keyring,kwallet### To disable all password stores, use an empty list:# password-stores =###### Set KWallet wallet used by Subversion. If empty or unset,### then the default network wallet will be used.# kwallet-wallet =###### Include PID (Process ID) in Subversion application name when### using KWallet. It defaults to &apos;no&apos;.# kwallet-svn-application-name-with-pid = yes###### Set ssl-client-cert-file-prompt to &apos;yes&apos; to cause the client### to prompt for a path to a client cert file when the server### requests a client cert but no client cert file is found in the### expected place (see the &apos;ssl-client-cert-file&apos; option in the### &apos;servers&apos; configuration file). Defaults to &apos;no&apos;.# ssl-client-cert-file-prompt = no###### The rest of the [auth] section in this file has been deprecated.### Both &apos;store-passwords&apos; and &apos;store-auth-creds&apos; can now be### specified in the &apos;servers&apos; file in your config directory### and are documented there. Anything specified in this section### is overridden by settings specified in the &apos;servers&apos; file.# store-passwords = no# store-auth-creds = no### Section for configuring external helper applications.[helpers]### Set editor-cmd to the command used to invoke your text editor.### This will override the environment variables that Subversion### examines by default to find this information ($EDITOR,### et al).# editor-cmd = editor (vi, emacs, notepad, etc.)editor-cmd = vim### Set diff-cmd to the absolute path of your &apos;diff&apos; program.### This will override the compile-time default, which is to use### Subversion&apos;s internal diff implementation.# diff-cmd = diff_program (diff, gdiff, etc.)diff-cmd = /usr/local/bin/svndiff.sh### Diff-extensions are arguments passed to an external diff### program or to Subversion&apos;s internal diff implementation.### Set diff-extensions to override the default arguments (&apos;-u&apos;).# diff-extensions = -u -p### Set diff3-cmd to the absolute path of your &apos;diff3&apos; program.### This will override the compile-time default, which is to use### Subversion&apos;s internal diff3 implementation.# diff3-cmd = diff3_program (diff3, gdiff3, etc.)### Set diff3-has-program-arg to &apos;yes&apos; if your &apos;diff3&apos; program### accepts the &apos;--diff-program&apos; option.# diff3-has-program-arg = [yes | no]### Set merge-tool-cmd to the command used to invoke your external### merging tool of choice. Subversion will pass 5 arguments to### the specified command: base theirs mine merged wcfile# merge-tool-cmd = merge_command### Section for configuring tunnel agents.[tunnels]### Configure svn protocol tunnel schemes here. By default, only### the &apos;ssh&apos; scheme is defined. You can define other schemes to### be used with &apos;svn+scheme://hostname/path&apos; URLs. A scheme### definition is simply a command, optionally prefixed by an### environment variable name which can override the command if it### is defined. The command (or environment variable) may contain### arguments, using standard shell quoting for arguments with### spaces. The command will be invoked as:### &lt;command&gt; &lt;hostname&gt; svnserve -t### (If the URL includes a username, then the hostname will be### passed to the tunnel agent as &lt;user&gt;@&lt;hostname&gt;.) If the### built-in ssh scheme were not predefined, it could be defined### as:# ssh = $SVN_SSH ssh -q -o ControlMaster=no### If you wanted to define a new &apos;rsh&apos; scheme, to be used with### &apos;svn+rsh:&apos; URLs, you could do so as follows:# rsh = rsh### Or, if you wanted to specify a full path and arguments:# rsh = /path/to/rsh -l myusername### On Windows, if you are specifying a full path to a command,### use a forward slash (/) or a paired backslash (\\) as the### path separator. A single backslash will be treated as an### escape for the following character.### Section for configuring miscellaneous Subversion options.[miscellany]### Set global-ignores to a set of whitespace-delimited globs### which Subversion will ignore in its &apos;status&apos; output, and### while importing or adding files and directories.### &apos;*&apos; matches leading dots, e.g. &apos;*.rej&apos; matches &apos;.foo.rej&apos;.# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo __pycache__# *.rej *~ #*# .#* .*.swp .DS_Store [Tt]humbs.db### Set log-encoding to the default encoding for log messages# log-encoding = latin1### Set use-commit-times to make checkout/update/switch/revert### put last-committed timestamps on every file touched.# use-commit-times = yes### Set no-unlock to prevent &apos;svn commit&apos; from automatically### releasing locks on files.# no-unlock = yes### Set mime-types-file to a MIME type registry file, used to### provide hints to Subversion&apos;s MIME type auto-detection### algorithm.# mime-types-file = /path/to/mime.types### Set preserved-conflict-file-exts to a whitespace-delimited### list of patterns matching file extensions which should be### preserved in generated conflict file names. By default,### conflict files use custom extensions.# preserved-conflict-file-exts = doc ppt xls od?### Set enable-auto-props to &apos;yes&apos; to enable automatic properties### for &apos;svn add&apos; and &apos;svn import&apos;, it defaults to &apos;no&apos;.### Automatic properties are defined in the section &apos;auto-props&apos;.# enable-auto-props = yes### Set interactive-conflicts to &apos;no&apos; to disable interactive### conflict resolution prompting. It defaults to &apos;yes&apos;.# interactive-conflicts = no### Set memory-cache-size to define the size of the memory cache### used by the client when accessing a FSFS repository via### ra_local (the file:// scheme). The value represents the number### of MB used by the cache.# memory-cache-size = 16### Set diff-ignore-content-type to &apos;yes&apos; to cause &apos;svn diff&apos; to### attempt to show differences of all modified files regardless### of their MIME content type. By default, Subversion will only### attempt to show differences for files believed to have human-### readable (non-binary) content. This option is especially### useful when Subversion is configured (via the &apos;diff-cmd&apos;### option) to employ an external differencing tool which is able### to show meaningful differences for binary file formats. [New### in 1.9]# diff-ignore-content-type = no### Section for configuring automatic properties.[auto-props]### The format of the entries is:### file-name-pattern = propname[=value][;propname[=value]...]### The file-name-pattern can contain wildcards (such as &apos;*&apos; and### &apos;?&apos;). All entries which match (case-insensitively) will be### applied to the file. Note that auto-props functionality### must be enabled, which is typically done by setting the### &apos;enable-auto-props&apos; option.# *.c = svn:eol-style=native# *.cpp = svn:eol-style=native# *.h = svn:keywords=Author Date Id Rev URL;svn:eol-style=native# *.dsp = svn:eol-style=CRLF# *.dsw = svn:eol-style=CRLF# *.sh = svn:eol-style=native;svn:executable# *.txt = svn:eol-style=native;svn:keywords=Author Date Id Rev URL;# *.png = svn:mime-type=image/png# *.jpg = svn:mime-type=image/jpeg# Makefile = svn:eol-style=native### Section for configuring working copies.[working-copy]### Set to a list of the names of specific clients that should use### exclusive SQLite locking of working copies. This increases the### performance of the client but prevents concurrent access by### other clients. Third-party clients may also support this### option.### Possible values:### svn (the command line client)# exclusive-locking-clients =### Set to true to enable exclusive SQLite locking of working### copies by all clients using the 1.8 APIs. Enabling this may### cause some clients to fail to work properly. This does not have### to be set for exclusive-locking-clients to work.# exclusive-locking = false### Set the SQLite busy timeout in milliseconds: the maximum time### the client waits to get access to the SQLite database before### returning an error. The default is 10000, i.e. 10 seconds.### Longer values may be useful when exclusive locking is enabled.# busy-timeout = 10000 找到： 1# store-passwords = no 改为： 1store-passwords = yes 保存，下次SVN操作的时候需要输入一次密码，之后就不用再输密码了。 切换SVN账号有时候需要切换SVN账号进行相应的操作，但是默认提示的是上一次操作的账号。碰到这个问题，只要删除/home/[username]/.subversion/auth即可。 1rm -rf /home/[username]/.subversion/auth 保存，下次SVN操作的时候就会提示输入用户名。 修改配置文件servers如果上面的方法没有解决每次都要输入密码的问题，可以继续修改servers配置文件。 用vim打开文件： 1vim /home/[username]/.subversion/servers 原文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170### This file specifies server-specific parameters,### including HTTP proxy information, HTTP timeout settings,### and authentication settings.###### The currently defined server options are:### http-proxy-host Proxy host for HTTP connection### http-proxy-port Port number of proxy host service### http-proxy-username Username for auth to proxy service### http-proxy-password Password for auth to proxy service### http-proxy-exceptions List of sites that do not use proxy### http-timeout Timeout for HTTP requests in seconds### http-compression Whether to compress HTTP requests### http-max-connections Maximum number of parallel server### connections to use for any given### HTTP operation.### http-chunked-requests Whether to use chunked transfer### encoding for HTTP requests body.### neon-debug-mask Debug mask for Neon HTTP library### ssl-authority-files List of files, each of a trusted CA### ssl-trust-default-ca Trust the system &apos;default&apos; CAs### ssl-client-cert-file PKCS#12 format client certificate file### ssl-client-cert-password Client Key password, if needed.### ssl-pkcs11-provider Name of PKCS#11 provider to use.### http-library Which library to use for http/https### connections.### http-bulk-updates Whether to request bulk update### responses or to fetch each file### in an individual request.### store-passwords Specifies whether passwords used### to authenticate against a### Subversion server may be cached### to disk in any way.### store-plaintext-passwords Specifies whether passwords may### be cached on disk unencrypted.### store-ssl-client-cert-pp Specifies whether passphrase used### to authenticate against a client### certificate may be cached to disk### in any way### store-ssl-client-cert-pp-plaintext### Specifies whether client cert### passphrases may be cached on disk### unencrypted (i.e., as plaintext).### store-auth-creds Specifies whether any auth info### (passwords, server certs, etc.)### may be cached to disk.### username Specifies the default username.###### Set store-passwords to &apos;no&apos; to avoid storing passwords on disk### in any way, including in password stores. It defaults to### &apos;yes&apos;, but Subversion will never save your password to disk in### plaintext unless explicitly configured to do so.### Note that this option only prevents saving of *new* passwords;### it doesn&apos;t invalidate existing passwords. (To do that, remove### the cache files by hand as described in the Subversion book.)###### Set store-plaintext-passwords to &apos;no&apos; to avoid storing### passwords in unencrypted form in the auth/ area of your config### directory. Set it to &apos;yes&apos; to allow Subversion to store### unencrypted passwords in the auth/ area. The default is### &apos;ask&apos;, which means that Subversion will ask you before### saving a password to disk in unencrypted form. Note that### this option has no effect if either &apos;store-passwords&apos; or### &apos;store-auth-creds&apos; is set to &apos;no&apos;.###### Set store-ssl-client-cert-pp to &apos;no&apos; to avoid storing ssl### client certificate passphrases in the auth/ area of your### config directory. It defaults to &apos;yes&apos;, but Subversion will### never save your passphrase to disk in plaintext unless### explicitly configured to do so.###### Note store-ssl-client-cert-pp only prevents the saving of *new*### passphrases; it doesn&apos;t invalidate existing passphrases. To do### that, remove the cache files by hand as described in the### Subversion book at http://svnbook.red-bean.com/nightly/en/\### svn.serverconfig.netmodel.html\### #svn.serverconfig.netmodel.credcache###### Set store-ssl-client-cert-pp-plaintext to &apos;no&apos; to avoid storing### passphrases in unencrypted form in the auth/ area of your### config directory. Set it to &apos;yes&apos; to allow Subversion to### store unencrypted passphrases in the auth/ area. The default### is &apos;ask&apos;, which means that Subversion will prompt before### saving a passphrase to disk in unencrypted form. Note that### this option has no effect if either &apos;store-auth-creds&apos; or### &apos;store-ssl-client-cert-pp&apos; is set to &apos;no&apos;.###### Set store-auth-creds to &apos;no&apos; to avoid storing any Subversion### credentials in the auth/ area of your config directory.### Note that this includes SSL server certificates.### It defaults to &apos;yes&apos;. Note that this option only prevents### saving of *new* credentials; it doesn&apos;t invalidate existing### caches. (To do that, remove the cache files by hand.)###### HTTP timeouts, if given, are specified in seconds. A timeout### of 0, i.e. zero, causes a builtin default to be used.###### Most users will not need to explicitly set the http-library### option, but valid values for the option include:### &apos;serf&apos;: Serf-based module (Subversion 1.5 - present)### &apos;neon&apos;: Neon-based module (Subversion 1.0 - 1.7)### Availability of these modules may depend on your specific### Subversion distribution.###### The commented-out examples below are intended only to### demonstrate how to use this file; any resemblance to actual### servers, living or dead, is entirely coincidental.### In the &apos;groups&apos; section, the URL of the repository you&apos;re### trying to access is matched against the patterns on the right.### If a match is found, the server options are taken from the### section with the corresponding name on the left.[groups]# group1 = *.collab.net# othergroup = repository.blarggitywhoomph.com# thirdgroup = *.example.com### Information for the first group:# [group1]# http-proxy-host = proxy1.some-domain-name.com# http-proxy-port = 80# http-proxy-username = blah# http-proxy-password = doubleblah# http-timeout = 60# neon-debug-mask = 130# store-plaintext-passwords = no# username = harry### Information for the second group:# [othergroup]# http-proxy-host = proxy2.some-domain-name.com# http-proxy-port = 9000# No username and password for the proxy, so use the defaults below.### You can set default parameters in the &apos;global&apos; section.### These parameters apply if no corresponding parameter is set in### a specifically matched group as shown above. Thus, if you go### through the same proxy server to reach every site on the### Internet, you probably just want to put that server&apos;s### information in the &apos;global&apos; section and not bother with### &apos;groups&apos; or any other sections.###### Most people might want to configure password caching### parameters here, but you can also configure them per server### group (per-group settings override global settings).###### If you go through a proxy for all but a few sites, you can### list those exceptions under &apos;http-proxy-exceptions&apos;. This only### overrides defaults, not explicitly matched server names.###### &apos;ssl-authority-files&apos; is a semicolon-delimited list of files,### each pointing to a PEM-encoded Certificate Authority (CA)### SSL certificate. See details above for overriding security### due to SSL.[global]# http-proxy-exceptions = *.exception.com, www.internal-site.org# http-proxy-host = defaultproxy.whatever.com# http-proxy-port = 7000# http-proxy-username = defaultusername# http-proxy-password = defaultpassword# http-compression = no# No http-timeout, so just use the builtin default.# No neon-debug-mask, so neon debugging is disabled.# ssl-authority-files = /path/to/CAcert.pem;/path/to/CAcert2.pem## Password / passphrase caching parameters:# store-passwords = no# store-ssl-client-cert-pp = no# store-plaintext-passwords = no# store-ssl-client-cert-pp-plaintext = no 找到： 12# store-passwords = no# store-plaintext-passwords = no 修改为： 12store-passwords = yesstore-plaintext-passwords = yes 保存，下次操作的时候就不用输入SVN密码了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端模板引擎FreeMarker]]></title>
    <url>%2F2017%2F09%2F30%2FJava%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreeMarker%2F</url>
    <content type="text"><![CDATA[业务后端使用的是Java后端，考虑到SEO是不可忽略的需求，采用FreeMarker模板引擎做页面开发。 待更新。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FreeMarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架引入的意义]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%BC%95%E5%85%A5%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[如今的 Web 前端领域什么最火？当然是前端框架啦。 React 听过吗？ Angular 听过吗？ Vue 听过么？如果都没有听过就不用往下看了。 前端框架与前端类库的区别jQuery 等库与前端 MVC 间的区别主要表现在以下几个方面： 二者解决的问题存在着一定的差异jQuery 主要应用于对代码、封装等问题的解决。而其也为系统实际运行提供了多种封装方法，由此稳固了代码结构的合理性设置，而前端 MVC 框架与 jQuery 等库在问题解决方面有所不同，其更加倾向于对程序组织方面问题的解决，进而推动系统中的程序运行逐渐趋于规范化。另外，前端框架为系统运行提供了一套规范化的问题解决方案，致使系统运行中出现相应问题时可及时参照方案对问题展开及时、有效的解决，且最终提高系统运行的稳定性； jQuery 的操作中心为 DOM ，而 MVC 框架的中心却为模型因而 MVC 与 jQuery 相比其流程的变更更为及时，且也为现代工程师的代码编写提供了有利条件。另外， MVC 框架解决了传统 HTML 源码处理中的问题，促使相关工作人员在实际工作开展过程中即可通过参照前端 MVC 框架中的规范化流程打通后端处理，提高系统中的整体运行效率。 近年来， Web 前端 MVC 框架的开发意义逐渐引起了人们的关注，而从 Web 前端 MVC 框架的适用范围研究中即可看出其在系统运行中占着至关重要的位置。对于此，可以从以下几个方面入手分析： 从大量的实践中可以看出， Web 前端 MVC 框架不适用于页面型产品中，造成此现象的原因主要归咎于此类产品主要依附于服务器来运作自身系统，因而在此背景下， jQuery 等库会更好的满足其互动性需求，且最终导致 Web 前端 MVC 框架在页面型产品中无法发挥其自身效用； 在软件型产品，对于 Web 前端 MVC 框架的应用是非常必要的。首先由于软件型产品对数据操作能力的要求较大，因而若将 Web 前端 MVC 框架应用于软件型产品实际运行中，那么框架中的数据模型层会在一定程度上满足其数据操作需求，且会在系统实际运行中出现问题时，对数据展开及时的更新处理。其次，软件型产品中会涉及到大量的视图操作，但是由于 jQuery 等库无法完成高效率的操作行为，因而将 Web 前端 MVC 框架应用于其中，会在一定程度上更好的满足程序开发需求。 参考：Web前端框架与类库的思考 | @ChokCoco]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你在阿里云ECS上配置HTTPS]]></title>
    <url>%2F2017%2F08%2F28%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%85%8D%E7%BD%AEHTTPS%2F</url>
    <content type="text"><![CDATA[上HTTPS的理由不用多说，直接上教程。 1.申请SSL证书免费申请阿里云SSL证书：传送门 按照阿里云的提示操作填写相关的信息、配置好自己的域名等信息。附上截图教程：传送门 2.配置nginx由初始的nginx我没有备份，这里就只附上最后配置完的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name xxx.com; add_header Strict-Transport-Security max-age=15768000; return 301 https://ricosmall.cn$request_uri; #charset koi8-r; #access_log logs/host.access.log main; #location / &#123; # root html; # index index.html index.htm; #&#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # server &#123; listen 443 ssl http2 default_server; server_name xxx.com; # 你的域名 add_header Strict-Transport-Security max-age=15768000; ssl_certificate path/to/xxx.pem; # pem文件位置 ssl_certificate_key path/to/xxx.key; # 私钥位置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers 'ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4'; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:20m; ssl_session_timeout 60m; location / &#123; root html; index index.html index.htm; &#125; &#125;&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>HTTPS</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你在阿里云ECS上面安装nginx]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[一直想给自己弄一个云服务器和自己的域名，现在抓住了机会。阿里云有免费和非常实惠的新手大礼包。如果你也想体验一下，可以试试，我当时申请的就是这种。 我选择的系统配置是Linux Ubuntu 14.04，如果你不是选的Linux，不用再往下看了。 nginx配置步骤1.下载 nginx源文件：传送门 openssl源文件：传送门 pcre源文件：传送门 zlib源文件：传送门 2.将下载的源文件放到ECS上去我是通过sftp的方式将文件放上去的 1234567891011# sftp模式登陆到服务器sftp name@ip# cd到你想放置临时文件的目录sftp&gt; cd /tmp# cd到你本机下载文件的位置sftp&gt; lcd ~/Download# 上传文件sftp&gt; put nginx.tar.gz openssl.tar.gz pcre.tar.gz zlib.tar.gz 3.登陆到服务器进行配置、安装、测试我使用ssh的方式 123456789101112# ssh登陆服务器ssh name@ip# cd到刚才上传文件的目录cd /tmp# 解压文件tar -xzf filename# 进入nginx源码目录做小小的修改，为了安全cd ./nginx/src/corevim nginx.h 源文件内容如下12345678910111213141516171819202122232425/* * Copyright (C) Igor Sysoev * Copyright (C) Nginx, Inc. */#ifndef _NGINX_H_INCLUDED_#define _NGINX_H_INCLUDED_#define nginx_version 1013004#define NGINX_VERSION "1.13.4"#define NGINX_VER "nginx/" NGINX_VERSION#ifdef NGX_BUILD#define NGINX_VER_BUILD NGINX_VER " (" NGX_BUILD ")"#else#define NGINX_VER_BUILD NGINX_VER#endif#define NGINX_VAR "NGINX"#define NGX_OLDPID_EXT ".oldbin"#endif /* _NGINX_H_INCLUDED_ */ 更改之后的文件内容如下12345678910111213141516171819202122232425/* * Copyright (C) Igor Sysoev * Copyright (C) Nginx, Inc. */#ifndef _NGINX_H_INCLUDED_#define _NGINX_H_INCLUDED_#define nginx_version 1013004#define NGINX_VERSION ""#define NGINX_VER "super" NGINX_VERSION#ifdef NGX_BUILD#define NGINX_VER_BUILD NGINX_VER " (" NGX_BUILD ")"#else#define NGINX_VER_BUILD NGINX_VER#endif#define NGINX_VAR "super"#define NGX_OLDPID_EXT ".oldbin"#endif /* _NGINX_H_INCLUDED_ */ 12345678910111213141516171819202122232425262728293031# cd到nginx目录，从core目录操作cd ../../# configure./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-openssl=/tmp/openssl --with-pcre=/tmp/pcre --with-zlib=/tmp/zlib# /usr/local/nginx 指的是最终编译安装到此路径# /tmp/openssl, /tmp/pcre, /tmp/zlib 对应解压源码文件夹位置# installmake install# 安装完之后到安装目录下去cd /usr/local/nginx# 检查一下是否安装配置成功cd ./sbin./nginx -t# 正常输出如下nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful# 如果看到如下结果，尝试重启一下The program 'nginx' can be found in the following packages: * nginx-core * nginx-extras * nginx-full * nginx-light * nginx-naxsiTry: apt-get install &lt;selected package&gt; 至此，已经成功安装好了nginx。 有人会问为什么不通过apt-get install nginx之类的命令来安装，我想说的是，那种方式就无法体验最新版的nginx了。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>阿里云</tag>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript跨域方法总结]]></title>
    <url>%2F2017%2F08%2F02%2FJavaScript%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[需要开发一个浏览器端检测的页面，碰到了跨域的问题。回过头来仔细研究一下跨域的问题，做个总结。 本文大部分引用了Rain Man的JavaScript跨域总结与解决办法]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>跨域</tag>
        <tag>jsonp</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS多行文本溢出省略显示]]></title>
    <url>%2F2017%2F08%2F01%2FCSS%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[本文参考了Lomu的文章CSS多行文本溢出省略显示 文本溢出我们经常用到的应该就是text-overflow:ellipsis了，相信大家也很熟悉，但是对于多行文本的溢出处理确接触的不是很多，最近在公司群里面有同事问到，并且自己也遇到过这个问题，所以专门研究过这个问题。 首先我们回顾一下以前实现单行缩略是可以通过下面的代码实现的（部分浏览器需要设置宽度）： 12345p &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; WebKit内核浏览器解决办法首先，WebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性： display: -webkit-box 将对象作为弹性伸缩盒子模型显示； -webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式； text-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。 具体代码参考如下： 1234567p &#123; overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 这个方法合适WebKit浏览器或移动端（绝大部分是WebKit内核的）浏览器，效果可以查看： 其他浏览器的解决方案目前没有什么CSS的属性可以直接控制多行文本的省略显示，比较靠谱的办法应该就是利用相对定位在最后面加上一个省略号了，代码可以参考下面： 123456789101112131415p &#123; position:relative; line-height:1.5em; /* 高度为需要显示的行数*行高，比如这里我们显示两行，则为3 */ height:3em; overflow:hidden;&#125;p:after &#123; content:"..."; position:absolute; bottom:0; right:0; padding: 0 5px; background-color: #fff;&#125; 效果如下： 不过这样会有一点问题： 需要知道显示的行数并设置行高才行； IE6/7不支持after和content，需要添加一个标签来代替； 省略号的背景颜色跟文本背景颜色一样，并且可能会遮住部分文字，建议可以使用渐变的png背景图片代替。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>text-overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Travis实现hexo博客的自动化部署]]></title>
    <url>%2F2017%2F08%2F01%2F%E4%BD%BF%E7%94%A8Travis%E5%AE%9E%E7%8E%B0hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[一直想写一篇文章，记录一下从搭建博客到实现用Travis-CI自动化部署博客的过程。憋到现在才写，拖了很久。 如何使用hexo搭建博客就不赘述了，请打开hexo的官网参考文档，很容易的。 第一次小跨越：实现博客同时部署到Coding和Github由于github在国内访问速度比较慢，比较合适的做法是：把博客静态资源在GitHub上面部署一份，同时在Coding(和GitHub原理一模一样)上也部署一份。如果没有自己的域名，这个时候就可以通过yourusername.github.io或者yourusername.coding.me访问到相同的博客页面。 原始方法一开始，我没有多想，按照原始的方法部署博客。过程就像下面这样： 12345678910111213141516171819# 1. 新建一篇文章hexo new post '文章标题'# 2. 编写文章内容vim 文章标题.md# 3. 生成静态博客代码hexo generate# 4. 部署博客代码到Githubhexo deploy# 5. 复制生成的博客代码到另一个Coding项目cp -r public ../blog-in-coding# 6. 部署博客代码到Codinggit add .git commit -m 'create a new post'git push origin master 每次这样显得特别原始，特别麻烦。一个程序员习惯这种机械的流程是没有好下场的。问题总结下来其实就是：是否可以同时将一份博客代码同时部署到两个远程仓库？这个问题我之前专门写了一篇文章做了介绍。传送门 这个问题得以解决，新的博客部署流程就变成了这样： 1234567891011# 1. 新建一篇文章hexo new post '文章标题'# 2. 编写文章内容vim 文章标题.md# 3. 生成静态博客代码hexo generate# 4. 部署博客代码到GitHub和Codinghexo deploy 已经省去了两个大的步骤。更进一步的做法就是把上面的3和4结合成一个命令：hexo deploy --generate。至此，基本上已经优化到一个不错的水平了。 第二次大跨越：使用Travis-CI实现Hexo博客的自动化部署]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Travis-CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可视化算法]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一篇赏心悦目的可视化算法文章。 Visualizing Algorithms 附上大牛的博客：Mike Bostock]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>可视化算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块简史]]></title>
    <url>%2F2017%2F07%2F04%2FJavaScript%E6%A8%A1%E5%9D%97%E7%AE%80%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[你是否是 JavaScript 新手？并且对模块，模块加载器和模块打包器感到困惑吗？或者你已经编写了一段时间的 JavaScript ，但是没法掌握模块的一些术语？你是否听过 CommonJS、AMD、Browserify、SystemJS、Webpack、JSPM 等等术语，但是不理解我们为什么需要它们？ 我会试着解释他们是什么，他们试图解决什么问题，以及他们如何解决这个问题。 中文翻译地址JavaScript模块简史 英文原版地址Brief history of JavaScript Modules 英文地址需要自备梯子。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript标准编码风格]]></title>
    <url>%2F2017%2F07%2F04%2FJavaScript%E6%A0%87%E5%87%86%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[JavaScript 代码规范，自带 linter &amp; 代码自动修正 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 JavaScript标准风格（首页） JavaScript Standard Style（全文） 下面是ExpressJS项目中遵循该风格的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/*! * body-parser * Copyright(c) 2014-2015 Douglas Christopher Wilson * MIT Licensed */'use strict'/** * Module dependencies. * @private */var deprecate = require('depd')('body-parser')/** * Cache of loaded parsers. * @private */var parsers = Object.create(null)/** * @typedef Parsers * @type &#123;function&#125; * @property &#123;function&#125; json * @property &#123;function&#125; raw * @property &#123;function&#125; text * @property &#123;function&#125; urlencoded *//** * Module exports. * @type &#123;Parsers&#125; */exports = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares')/** * JSON parser. * @public */Object.defineProperty(exports, 'json', &#123; configurable: true, enumerable: true, get: createParserGetter('json')&#125;)/** * Raw parser. * @public */Object.defineProperty(exports, 'raw', &#123; configurable: true, enumerable: true, get: createParserGetter('raw')&#125;)/** * Text parser. * @public */Object.defineProperty(exports, 'text', &#123; configurable: true, enumerable: true, get: createParserGetter('text')&#125;)/** * URL-encoded parser. * @public */Object.defineProperty(exports, 'urlencoded', &#123; configurable: true, enumerable: true, get: createParserGetter('urlencoded')&#125;)/** * Create a middleware to parse json and urlencoded bodies. * * @param &#123;object&#125; [options] * @return &#123;function&#125; * @deprecated * @public */function bodyParser (options) &#123; var opts = &#123;&#125; // exclude type option if (options) &#123; for (var prop in options) &#123; if (prop !== 'type') &#123; opts[prop] = options[prop] &#125; &#125; &#125; var _urlencoded = exports.urlencoded(opts) var _json = exports.json(opts) return function bodyParser (req, res, next) &#123; _json(req, res, function (err) &#123; if (err) return next(err) _urlencoded(req, res, next) &#125;) &#125;&#125;/** * Create a getter for loading a parser. * @private */function createParserGetter (name) &#123; return function get () &#123; return loadParser(name) &#125;&#125;/** * Load a parser module. * @private */function loadParser (parserName) &#123; var parser = parsers[parserName] if (parser !== undefined) &#123; return parser &#125; // this uses a switch for static require analysis switch (parserName) &#123; case 'json': parser = require('./lib/types/json') break case 'raw': parser = require('./lib/types/raw') break case 'text': parser = require('./lib/types/text') break case 'urlencoded': parser = require('./lib/types/urlencoded') break &#125; // store to prevent invoking require() return (parsers[parserName] = parser)&#125;]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式（一）]]></title>
    <url>%2F2017%2F06%2F13%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建对象的基本模式JavaScript中创建对象的基本模式有3种。第一种是门户大开型，它只能提供公用成员；第二种是使用下划线来表示方法或属性的私用性；第三种做法使用闭包来创建真正私用的成员，这些成员只能通过一些特权方法来访问。 不能简单地说这些定义类的模式中哪种是‘正确的’。它们各有利弊。 门户大开型对象创建一个类，用一个函数来做其构造器。我们称其为门户大开型对象，因为它的所有属性和方法都是公开的、可访问的。这些公用属性要使用this关键字来创建： 1234567891011var Book = function (isbn, title, author) &#123; if (isbn == undefined) throw new Error('Book constructor requires an isbn.'); this.isbn = isbn; this.title = title || 'No title specified'; this.author = author || 'No author specified';&#125;Book.prototype.display = function () &#123; ...&#125;; 乍一看这个类似乎符合一切需求。但是最大的问题是你无法检验ISBN数据的完整性，而不完整的ISBN数据有可能导致display方法失灵。这破坏了你与其他程序员之间的契约。如果Book对象在创建的时候没有抛出任何错误，那么display方法应该能够正常工作才是，但是由于没有进行完整性检查，这就不一定了。因此需要强化一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var Book = function (isbn, title, author) &#123; if (!this.checkIsbn(isbn) throw new Error('Book: Invalid ISBN.')); this.isbn = isbn; this.title = title || 'No title specified'; this.author = author || 'No author specified';&#125;Book.prototype = &#123; checkIsbn: function (isbn) &#123; if (isbn == undefined || typeof isbn != 'string') &#123; return false; &#125; &#125; isbn = isbn.replace(/-/, ''); if (isbn.length != 10 &amp;&amp; isbn.length != 13) &#123; return false; &#125; var sum = 0; if (isbn.length === 10) &#123; if (!isbn.match(/^\d&#123;9&#125;/)) &#123; return false; &#125; for (var i = 0; i &lt; 9; i++) &#123; sum += isbn.charAt(i) * (10 - i); &#125; var checksum = sum % 11; if (checksum === 10) checksum = 'X'; if (isbn.charAt(9) != checksum) &#123; return false; &#125; &#125; else &#123; if (!isbn.match(/^\d&#123;12&#125;/)) &#123; return false; &#125; for (var i = 0; i &lt; 12; i++) &#123; sum += isbn.charAt(i) * ((i % 2 === 0) ? 1 : 3); &#125; var checksum = sum % 10; if (isbn.charAt(12) != checksum) &#123; return false; &#125; &#125;, display: function () &#123; ... &#125;&#125; 现在看起来情况有所改善。在创建对象的时候可以对ISBN的有效性进行检查，这可以确保display方法能正常工作。但是现在又出现另一个问题。假设另一个程序员认识到一本书可能会有很多个版本，每个版本都有自己的ISBN。他设计了一个用来在这些不同版本之中进行选择的算法，并在实例化书籍对象之后直接用它修改isbn属性： 12theHobbit.isbn = '978-0261103283';theHobbit.display(); 即使能在构造器中对数据的完整性进行检验，你对其他程序员会把什么样的值直接赋给isbn属性还是毫无控制。为了保护内部数据，你为每个属性都提供了取值器和赋值器方法。取值器方法用于获取属性值，而赋值器方法则用于设置属性值。通过使用赋值器，你可以把一个新值真正赋给属性之前进行各种检验。下面是加了取值器和赋值器方法之后的新版Book对象： 1234567891011121314151617181920212223242526272829303132333435363738// Interface类的源码见文章末尾var Publication = new Interface('Publication', ['getIsbn', 'setIsbn', 'getTitle', 'setTitle', 'getAuthor', 'setAuthor', 'display']);var Book = function (isbn, title, author) &#123; this.setIsbn(isbn); this.setTitle(title); this.setAuthor(author);&#125;;Book.prototype = &#123; checkIsbn: function (isbn) &#123; ... &#125;, getIsbn: function () &#123; return this.isbn; &#125;, setIsbn: function (isbn) &#123; if (!this.checkIsbn(isbn)) throw new Error('Book: Invalid ISBN.'); this.isbn = isbn; &#125;, getTitle: function () &#123; return this.title; &#125;, setTitle: function (title) &#123; this.title = title || 'No title specified'; &#125;, getAuthor: function () &#123; return this.author; &#125;, setAuthor: function (author) &#123; this.author = author || 'No author specified'; &#125;, display: function () &#123; ... &#125;&#125;; 虽然我们为设置属性提供了赋值器方法，但是那些属性仍然是公开的，可以被设置。 用命名规范区别私用成员下划线是一个众所周知的命名规范，它表明一个属性（或方法）仅提供对象内部使用，直接访问它或者设置它可能会导致意想不到的后果。 1234567891011121314151617181920212223242526272829303132333435var Book = function (isbn, title, author) &#123; this.setIsbn(isbn); this.setTitle(title); this.setAuthor(author);&#125;;Book.prototype = &#123; _checkIsbn: function (isbn) &#123; ... &#125;, getIsbn: function () &#123; return this._isbn; &#125;, setIsbn: function (isbn) &#123; if (!this._checkIsbn(isbn)) throw new Error('Book: Invalid ISBN.'); this._isbn = isbn; &#125;, getTitle: function () &#123; return this._title; &#125;, setTitle: function (title) &#123; this._title = title || 'No title specified'; &#125;, getAuthor: function () &#123; return this._author; &#125;, setAuthor: function (author) &#123; this._author = author || 'No author specified'; &#125;, display: function () &#123; ... &#125;&#125;; 这有助于程序员对它的无意使用，但是不能防止对它的有意使用。 用闭包实现私用成员12345678910111213141516171819202122232425262728293031323334353637383940var Book = function (newIsbn, newTitle, newAuthor) &#123; var isbn, title, author; function checkIsbn(isbn) &#123; ... &#125; this.getIsbn = function () &#123; return isbn; &#125;; this.setIsbn = function (newIsbn) &#123; if (!checkIsbn(newIsbn)) throw new Error('Book: Invalid ISBN.'); isbn = newIsbn; &#125;; this.getTitle = function () &#123; return title; &#125;; this.setTitle = function (newTitle) &#123; title = newTitle || 'No title specified'; &#125;; this.getAuthor = function () &#123; return author; &#125;; this.setAuthor = function (newAuthor) &#123; author = newAuthor || 'No author specified'; &#125;; this.setIsbn(newIsbn); this.setTitle(newTitle); this.setAuthor(newAuthor);&#125;;Book.prototype = &#123; display: function () &#123; ... &#125;&#125;; Interface类的源码如下：12345678910111213141516171819202122232425262728293031323334353637383940var Interface = function (name, methods) &#123; if (arguments.length != 2) &#123; throw new Error('Interface constructor called with ' + arguments.length + 'arguments, but expected exactly 2.'); &#125; this.name = name; this.methods = []; for (var i = 0, len = methods.length; i &lt; len; i++) &#123; if (typeof methods[i] !== 'string') &#123; throw new Error('Interface constructor expects method names to be ' + 'passed in as a string.'); &#125; this.methods.push(methods[i]); &#125;&#125;;Interface.ensureImplements = function (object) &#123; if (arguments.length &lt; 2) &#123; throw new Error('Function Interface.ensureImplements called with ' + arguments.length + 'arguments, but expected at least 2.'); &#125; for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; var interface = arguments[i]; if (interface.constructor !== Interface) &#123; throw new Error('Function Interface.ensureImplements expects ' + 'arguments two and above to be instances of Interface.'); &#125; for (var j = 0, methodsLen = interface.methods.length; j &lt; methodsLen; j++) &#123; var method = interface.methods[j]; if (!object[method] || typeof object[method] !== 'function') &#123; throw new Error('Function Interface.ensureImplements: object ' + 'does not implement the ' + interface.name + 'interface. Method ' + method + 'was not found.'); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript开发规范]]></title>
    <url>%2F2017%2F06%2F02%2FJavaScript%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1. 命名规范驼峰式命名法：驼峰式命名法由大（小）写字母开始，后续每个单词首字母都大写。按照第一个字母是否大写，分为： Pascal Case 大驼峰式命名法：首字母大写。如：StudentInfo Camel Case 小驼峰式命名法：首字母小写。如：studentInfo 1.1 变量命名方法： 小驼峰式命名法命名规范： 前缀应当是名词。（函数的名字前缀为动词，以此区分变量和函数）命名建议：尽量在变量名字中体现所属类型，如：length、count等表示数字类型；而包含name、title表示为字符串类型。 示例： 1234567// goodvar maxCount = 10;var tableTitle = 'LoginTable';// badvar setCount = 10;var getTitle = 'LoginTable'; 1.2 函数命名方法：小驼峰式命名法命名规范：前缀应当为动词命名建议：可以使用常见动词约定 动词 含义 返回值 can 判断是否可执行某个动作（权限） Boolean has 判断是否含有某个值 Boolean is 判断是否为某个值 Boolean get 获取某个值 NOT Boolean set 设置某个值 无返回值、Boolean或者返回链式对象 load 加载某些数据 无返回值或加载状态 示例： 123456789// 判断是否可读function canRead() &#123; return true;&#125;// 获取名字function getName() &#123; return this.name;&#125; 1.3 常量命名方法：名称全部大写命名规范：使用大写字母和下划线组合命名，下划线用以分割单词命名建议：参照1.1 示例： 12var MAX_COUNT = 10;var URL = 'http://www.lrts.me'; 1.4 构造函数命名方法：大驼峰式命名法命名规范：前缀为名称命名建议：无 示例： 12345function Student(name) &#123; this.name = name;&#125;var student1 = new Student('Tom'); 1.5 类的成员命名建议： 公共属性和方法：跟变量和函数的命名一样 私有属性和方法：前缀为_（下划线），后面跟公共属性和方法一样的命名方式 示例： 123456789101112131415161718function Student(name) &#123; // 私有属性 var _name = name; // 公共方法 this.getName = function () &#123; return _name; &#125; this.setName = function (value) &#123; _name = value; &#125;&#125;var student1 = new Student('Tom');student1.setName('John');console.log(student1.getName()); // =&gt; John 2. 注释规范JavaScript支持两种不同类型的注释：单行注释和多行注释。 2.1 单行注释说明：单行注释以两个斜杠开始，以行尾结束语法：// 这是单行注释使用方式： 单独一行：// comments 双斜杠与文字之间保留一个空格 在代码后面添加注释：var MAX_COUNT = 10; // comments 双斜杠与代码结尾之间保留一个空格，与注释文字之间保留一个空格。 注释代码：// var MAX_COUNT = 10; 双斜杠与代码之间保留一个空格。 示例： 1234567// 单独一行setCount();var MAX_COUNT = 10; // 在代码后面添加注释// 注释代码// setName(); 2.2 多行注释说明：以/*开头，以*/结尾语法：/* comments */使用方法： 若/*和*/在同一行，推荐采用单行注释 若至少三行注释，第一行为/*，最后一行为*/，其他行以*开始，与注释文字之间保留一个空格，并且所有的*保持竖向对齐 示例： 12345/* * comments line one * comments line two */setName(); 2.3 函数（方法）注释说明：函数（方法）注释也是多行注释的一种，但是包含了特殊的注释要求。语法：1234/** * 函数说明 * @关键字 */ 常用注释关键字：（只列出一部分） 注释名 语法 含义 示例 @param @param 参数名 {参数类型} 描述信息 描述参数的信息 @param name {String} 名称 @return @return {返回类型} 描述信息 描述返回值的信息 @return {String} 名称 @author @author 作者名字 附属信息 描述此函数或者模块的作者信息 @author Tom 2016-10-10 @version @version xx.xx.xx 描述此函数或者模块的版本号 @version 1.0.1 @example @example 示例代码 示例函数使用方法 @example setName(‘John’) 示例： 12345678910111213141516171819/** * 合并Grid的行 * @param grid &#123;Ext.Grid.Panel&#125; 需要合并的Grid * @param cols &#123;Array&#125; 需要合并的Index（序号）数组；从0开始计数，序号也包含 * @param isAllSome &#123;Boolean&#125; 是否2个tr的cols必须完全一样才能进行合并。true: 完全一样；false(默认): 不完全一样 * @return void * @author polk6 2015/07/21 * @example * ______________ ______________ * | 年龄 | 姓名 | | 年龄 | 姓名 | * -------------- mergeCells(grid, [0]) -------------- * | 18 | 张三 | =&gt; | | 张三 | * -------------- | 18 |------- * | 18 | 王五 | | | 王五 | * -------------- -------------- */function mergeCells(grid, cols, isAllSome) &#123; // do something&#125; 3. 框架开发在团队开发或者引入第三方JS的时候，有时候会造成全局对象的命名冲突，比如a.js有个全局函数sendMsg()，b.js也有个全局函数sendMsg()，引入a.js和b.js文件时，会造成sendMsg()函数冲突。 示例： 123456789101112全局变量冲突：b.js会覆盖a.js的同名函数 // a.js ------------------------ +----&gt; | function sendMsg() &#123; |&lt;script src=&quot;/js/b.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;---+ | alert(&apos;a&apos;); |&lt;script src=&quot;/js/a.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;---+ | &#125; |&lt;script type=&quot;text/javascript&quot;&gt; | ------------------------ | // b.js sendMsg(); // =&gt; ‘b’ | ------------------------- | | function sendMsg() &#123; |&lt;/script&gt; +----&gt; | alert(&apos;b&apos;); | | &#125; | ------------------------- 3.2 单全局变量所创建的全局对象名称是独一无二的，并将所有的功能代码添加到这个全局对象上。调用自己所写的代码时，以这个全局对象为入口。 如： jQuery的全局对象：$和jQuery ExtJS的全局对象：Ext 示例： 123456789101112131415全局变量冲突：b.js和a.js都有各自的主对象。 // a.js ----------------------------- | var A = A || &#123;&#125;; | +----&gt; | A.sendMsg = function () &#123; |&lt;script src=&quot;/js/b.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;---+ | alert(&apos;a&apos;); |&lt;script src=&quot;/js/a.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;---+ | &#125; |&lt;script type=&quot;text/javascript&quot;&gt; | ----------------------------- | // b.js A.sendMsg(); // =&gt; ‘a’ | ------------------------------ | | var B = B || &#123;&#125;; | | | B.sendMsg = function () &#123; | B.sendMsg(); // =&gt; &apos;b&apos; +----&gt; | alert(&apos;b&apos;); | | &#125; | ------------------------------&lt;/script&gt; 3.3 命名空间在项目规模日益壮大时，可采用命名空间的方式对JS代码进行规范：即将代码按照功能进行分组，以组的形式附加到单全局对象上。 以Ext的chart模块为例： 123456789101112131415161718 ------------ +---&gt; | Axis | | ------------ | ------------ +---&gt; | Category | 子模块名称 | ------------ ---------- | ------------ +---&gt; | axis | --+---&gt; | ... | 模块名称 | ---------- ------------ --------- | ---------- ------------ +---&gt; | chart | --+---&gt; | series | --+---&gt; | Area |单全局对象 | --------- | ---------- | --------------------- | | ---------- | ------------| Ext | --+ +---&gt; | ... | +---&gt; | Bar |--------- | ---------- | ------------ | --------- | ------------ +---&gt; | ... | +---&gt; | ... | --------- ------------]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript创建对象的方式汇总]]></title>
    <url>%2F2017%2F05%2F27%2FJavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[JavaScript中创建对象的方式有很多种，每一种方式都有相应的优缺点，总结如下。 工厂模式123456789101112function createPerson( name ) &#123; var obj = new Object(); obj.name = name; obj.getName = function () &#123; console.log( this.name ); &#125;; return obj;&#125;var person = createPerson('John'); 优点：简单直观 缺点：所有实例都指向同一个原型，无法辨识 构造函数模式123456789function Person( name ) &#123; this.name = name; this.getName = function () &#123; console.log( this.name ); &#125;;&#125;var person1 = new Person( 'John' ); 优点：实例可以识别一个特定的原型 缺点：每次实例化都会重新创建所有的方法 构造函数模式优化12345678function Person( name ) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log( this.name );&#125; 优点：解决了每次实例化都要创建所有方法的问题 缺点：没有封装性可言 原型模式1234567891011function Person( name ) &#123;&#125;Person.prototype.name = 'John';Person.prototype.getName= function () &#123; console.log( this.name );&#125;;var person1 = new Person(); 优点：方法共享，不会被重建 缺点：所有属性都是共享的；不能初始化参数 原型模式优化123456789101112function Person( name ) &#123;&#125;Person.prototype = &#123; name: 'John', getName: function () &#123; console.log( this.name ); &#125;&#125;;var person1 = new Person(); 优点：有一定的封装性 缺点：重写了原型，丢失了constructor属性 原型模式再优化12345678910111213function Person( name ) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'John', getName: function () &#123; console.log( this.name ); &#125;&#125;;var person1 = new Person(); 优点：可以通过constructor找到对应的构造函数 缺点：原型模式的公共缺点 组合模式123456789101112function Person( name ) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log( this.name ); &#125;&#125;;var person1 = new Person( 'John' ); 优点：使用广泛的模式，没有明显的毛病 缺点：需要更好的封装性 动态原型模式123456789101112function Person( name ) &#123; this.name = name; if (typeof this.getName !== 'function') &#123; Person.prototype.getName = function () &#123; console.log( this.name ); &#125;; &#125;&#125;var person1 = new Person( 'John' ); 优点：按需创建方法 缺点：没有明显的缺点 寄生构造函数模式1234567891011121314function Person( name ) &#123; var obj = new Object(); obj.name = name; obj.getName = function () &#123; console.log( this.name ); &#125;;&#125;var person1 = new Person( 'John' );console.log( person1 instanceof Person ); // falseconsole.log( person1 instanceof Object ); // true 寄生构造函数和工厂模式的区别就是实例化的时候需要new。 优点：可以在不影响原生对象基础上扩展原生对象的方法、属性，形成新的构造函数 缺点：instanceof无法指向构造函数 稳妥构造函数模式12345678910function person( name ) &#123; var obj = new Object(); obj.getName = function () &#123; console.log( name ); &#125;&#125;var person1 = person( 'John' ); 稳妥对象，指的是没有公共属性，方法中也不引用this的对象。 与寄生构造函数模式有两点不同： 方法中不引用this 实例化不用new 优点：适合用在比较安全的环境 缺点：和工厂模式一样，无法识别对象类型]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>构造函数</tag>
        <tag>JavaScript对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quantum聚焦：什么是浏览器引擎？]]></title>
    <url>%2F2017%2F05%2F17%2FQuantum%E8%81%9A%E7%84%A6%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[原文地址 2016年10月的时候我们宣布了Quantum项目–我们计划开发下一代浏览器引擎。现在该项目正在顺利进行。事实上我们已经将Quantum项目的阶段性成果应用到了Firefox 53中。 但是，我们意识到对于不开发浏览器的人（其实是大多数人）来说，要理解我们做的一些改变为什么对Firefox如此重要是很困难的。毕竟我们做的大多数改变对用户来说是不可见的。 考虑到这一点，我们开始撰写一系列的博客文章，使大家对我们在Quantum项目中所做的事情有一个更深层的理解。我们希望这一系列的文章能够让你们更好地理解Firefox是如何工作的，同时了解Firefox采用的方式是构建下一代浏览器引擎以更好地利用现代计算机硬件。 作为这一系列文章的开始，我们认为解释Quantum正在改变的基础原理是最合适的。 什么是浏览器引擎，它是怎么工作？ 那么要从哪里开始呢？我们认为应该从头开始。 浏览器就是一个软件，它的功能是加载文件（通常从远程服务器）并且在本地显示出来，允许用户和页面交互。 Quantum是我们Mozilla正在进行的一个项目，旨在大规模升级Firefox的一部分，这部分的功能就是基于远程文件计算出要呈现给用户的东西。这部分的专业术语叫“浏览器引擎”。如果没有这部分，你所看到的将会是一行行代码，而不是现在所看到的页面。Firefox的浏览器引擎名字叫Gecko。 简单来说，可以把浏览器引擎比喻成一个黑盒子，就像电视盒子，这个黑盒子从网络接收数据然后把数据计算成要显示在屏幕上的图像。今天的问题是：怎么做到的？把数据计算成我们看到的网页经历了哪些步骤？ 组成一个网页的数据包含很多东西，但是基本上可以分解成3个部分： 表示网页结构的代码 提供样式的代码：网页结构的视觉外观 浏览器行为的脚本代码：对用户的行为进行计算并作出反馈，对网页的结构和样式作出改变 浏览器引擎把结构和样式结合在一起，用来绘制显示在屏幕上的网页，并且计算出哪些部分是可以进行交互的。 这一切都始于结构。当你要求浏览器加载一个网站，你会给它一个地址。这个地址对应的是另一台电脑，这台电脑收到请求就会发送数据给你的浏览器。发送数据给浏览器的细节在另一篇文章做了详述。总之最后浏览器拿到了数据。数据以HTML的格式返回，用于描述网页的结构。浏览器又是怎么理解HTML的呢？ 浏览器引擎包含了一系列特殊的代码，叫做解析器，它可以把浏览器存在内存中的数据从一种格式转换成另一种格式。HTML解析器专门负责解析HTML数据，例如： 1234&lt;section&gt; &lt;h1 class="main-title"&gt;Hello!&lt;/h1&gt; &lt;img src="http://example.com/image.png"&gt;&lt;/section&gt; 解析过程描述如下： 123好的，这是个section。包含在section里面的有一个个h1的标题，标题的内容为&apos;Hello!&apos;；还有一张图片也包含在section里面，图片的数据源为&apos;http://example.com/image.png&apos;。 内存中的网页结构叫做文档对象模型或者DOM。和一长串的文字形式相反，DOM表示为最终网页的元素组成的一棵树：元素包含哪些属性，哪些元素包含在其他元素中。 除了描述页面的结构，HTML里面也包含了样式和脚本的资源地址。当浏览器找到这些地址，就会去请求对应的地址并加载对应的数据。然后这些数据被传给专门处理这些数据格式的解析器。如果脚本被找到了，在HTML解析完成之前，这些脚本可以改变页面的结构和样式。作为样式格式，CSS在浏览器引擎中扮演下一个角色。 样式CSS是一种编程语言，开发者可以用这种编程语言去定义页面中特定元素的外观。CSS的全称是”Cascading Style Sheets”（层叠样式表），之所以这样命名，是因为它允许很多样式指令集合，在这些样式指令集中，新的指令可以覆盖旧的或者默认的指令（叫做层叠）。下面是一小段CSS示例： 1234567891011121314section &#123; font-size: 15px; color: #333; border: 1px solid blue;&#125;h1 &#123; font-size: 2em;&#125;.main-title &#123; font-size: 3em;&#125;img &#123; width: 100%;&#125; CSS被大量分解成被称为规则的组合，这些组合都是由两部分组成。第一部分是选择器。选择器表示DOM中需要更改样式的元素（还记得上面的描述吗？）。另一部分是一个列表，包含着将要应用到选择器对应元素的样式声明列表。浏览器引擎包含了一个子引擎，名字叫样式引擎，它的工作就是将CSS代码指定的样式应用到HTML解析器解析出来的DOM中去。 举例来说，在上面那段CSS代码中，我们声明的一些样式规则，目标选择器是“section”，这个选择器会和DOM中的同名元素匹配。之后样式说明会逐一应用到DOM中的每一个元素。最终DOM中的每一个元素都会被加上样式，我们把这种状态叫做元素的计算样式。当多种样式规则都被应用到同一个元素上的时候，那些排在后面的会覆盖掉排在前面的，定义的样式声明多的会覆盖样式声明少的。可以把样式表想象成临摹用的半透明的薄纸，每一层可以覆盖前面一层，但是同时又能够透过去看到上面一层。 一旦浏览器引擎拿到了计算样式，就会马上用起来。DOM和计算样式都会传给一个布局引擎，这个布局引擎可以计算将要展示页面的窗口的尺寸。布局引擎采用了一系列算法，画一个盒子，然后拿一个元素，把元素的内容以及应用在该元素上的样式依照规则放进盒子里。 布局完成之后要做的就是把页面转换成最终你看到的样子。这个过程被称为渲染，它是所有前面进行的步骤的最终结合。每个被布局定义好的盒子都被绘制好，包括来自DOM的所有内容和来自CSS的所有样式。现在，用户看到了通过对代码重新组装的页面。 以上就是发生的一切。 当用户滚动页面的时候，我们会重绘，然后呈现页面中未被显示在窗口中的新的部分。然而，事实证明用户喜欢滚动！浏览器引擎确信它将会被要求显示初始窗口（我们称为视口）以外的内容。很多现代浏览器深知这一点，因此一开始就会绘制更多的可见内容。当用户滚动的时候，他们想看到的部分其实早已经绘制好并且等着了。结果使滚动变得快速而又平滑。这个技术是合成的基础，一种用于减少页面绘制请求次数的技术手段。 另外，有时候我们需要重绘当前屏幕上的一部分。也许用户正在观看一个60帧每秒的视频。也许页面上有一张幻灯片或者动画列表。浏览器能够检测到到页面的一部分会发生移动或者更新，并且会创建一个控制该部分内容的层，而不是重绘整个页面。一个页面可以有很多层，一层覆盖另一层。其中的某一层可以改变位置，滑动，透明，后置或者前置于另一个不需要重绘任何东西的层。非常方便不是吗？ 有时候一个脚本或者一个动画会改变元素的样式。当这个发生的时候，样式引擎需要重新计算这个元素的样式（有可能是页面中更多的元素），重新布局（做一个重排），然后重绘这个页面。这些计算将会花费很多时间，但是只要这种事情只是偶尔发生，那么对用户体验来说不会产生消极的影响。 在现代网页应用中，DOM结构被脚本频繁地改变。这将使整个渲染过程或多或少出现终止并重新开始，同事伴随着HTML被解析到DOM，样式计算，重排和重绘。 标准不是每一个浏览器都用同样的方式去解析HTML，CSS和JavaScript。不同的浏览器渲染出来的页面可能不同：小到局部样式不同，大到整个网站可能只能在一个浏览器运行而其他浏览器都不行。目前，在现代网络中，大多数网站都能正常运行在你使用的浏览器中，不管你使用的是哪个浏览器。这些浏览器是怎么实现这么高的一致性的呢？ 网站代码的格式，和控制代码如何被解析成可见的交互页面的规则，都是被大家都同意的文件定义的，这个文件就叫做标准（规范）。这些标准都是由一个委员会制定，这个委员会由浏览器厂商的代表、web开发者、设计师和这个行业的其他人员组成的。他们一起决定一个浏览器引擎的精确行为：给一段特定的代码，完成对应的展示。这里有HTML，CSS和JavaScript的规范以及图片、视频、音频的数据格式等等。 为什么这个很重要？开发一个全新的浏览器引擎是可行的，只要你确保你的引擎遵循了标准，这个引擎会以和其他所有浏览器一样的方式去为网络上数以十亿计的网页做绘制渲染工作。这意味着让网站正常工作的秘诀不属于任何一个浏览器专属。标准允许用户去选择能满足他们需求的浏览器。 摩尔定律不再当恐龙漫步在地球上而且人们只有桌面电脑，电脑只会变得更快更强大是一个相对安全的假设。这个想法基于摩尔定律，摩尔定律描述的是一种现象：组件的密度会每两年增加一倍。令人难以置信的是，这个现象在21世纪一直存在，有些人甚至认为，在最新的研究中仍然是正确的。那么为什么在最近的10年里普通电脑的速度趋于平稳？ 用户去购买电脑的时候，处理速度不是用户看重的唯一特性。速度快的电脑会非常耗能，发热严重，而且非常贵。有时候，人们需要一款续航很好的电脑。有时候，他们需要一款微型的触控电脑，可以放进裤兜里，而且一整天都不用充电。先进的计算技术使得这个成为可能（令人惊讶！），但是是以原始速度为代价的。就像汽车一样，不可能越快越高效，电脑也是一样的。解决方案就是在一个CPU芯片上集成很多个“电脑”（核心）。一个智能手机拥有4个低性能的核心是很常见的。 不幸的是，浏览器的历史设计对上行速度做了假设。而且，要编写能够同时利用CPU的多核心的代码是很复杂的。如此一来，在这个到处都是小电脑的时代，我们要如何创造一个快速、高效的浏览器呢？ 我们有一些想法。 在接下来的几个月里，我们一起来仔细看看Firefox上的一些新的变化，以及Firefox是如何充分利用硬件的优势呈现一个快速稳定的浏览器来点亮网站的吧。 前进！ 以上。我第一完整地翻译一篇英文技术文章，文中有诸多生硬拗口甚至难以理解的地方。请看官们帮忙指正，勿喷。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染引擎原理</tag>
        <tag>Gecko</tag>
        <tag>Firefox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用软件收集]]></title>
    <url>%2F2017%2F05%2F04%2FMac%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[macOS作为开发者，macOS是最合适的平台。有人可能无法理解，我的建议是试试就知道。 常用软件Snip 截图软件，qq 开发一款很好用的截图工具。Alfred 快速启动、搜索工具，比自带的 spotlight 强太多了。Launchbar 同 Alfred，但是理念不同，也很强大。Cornerstone 强大的 mac 版 SVN 版本管理 GUI 软件。MacDown mac 版 Markdown 编辑器。MPlayerX mac 版视频播放器，好用。The Unarchiver mac 版文件解压工具。Spectacle mac 版分屏工具。]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数加法、乘法的JavaScript实现]]></title>
    <url>%2F2017%2F03%2F30%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%E3%80%81%E4%B9%98%E6%B3%95%E7%9A%84JavaScript%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在某些情况下，我们要处理很大的整数，它无法在计算机硬件能直接表示的范围内进行处理。若用浮点数来表示它，则只能近似地表示它的大小，计算结果中的有效数字也受到限制。若要精确地表示大整数并在计算结果中要求精确地得到所有位数上的数字，就必须用软件的方法来实现大整数的算术运算。 – 引用混沌的原话。 大整数加法在另一篇文章中已经整理过，在这里再贴一次吧。这不是我自己想出来的方法，这是在网上找的大神写的方法，具体源头我也没找到。至少我找到的算法里面没有比这个更简单的了。 12345678910111213141516171819202122232425// 方法var bigNumStringAddition = (a, b) =&gt; &#123; let result = '', tempVal = 0, arra = a.split(''), arrb = b.split(''); while (arra.length || arrb.length || tempVal) &#123; tempVal += ~~arra.pop() + ~~arrb.pop(); result = tempVal % 10 + result; tempVal = tempVal &gt; 9; &#125; return result.replace(/^0+/, '');&#125;;// 测试bigNumStringAddition('87683997878946347862738468726348289374972938479823749872938479234923846237672364732478237492394738748273948789237487238472389478923748782364723647823847283974', '92734897238947832456237489273498723984782365783465782634786287346782638472983749823748357634785278348273498723894792387489327487238478234827389472938748923748235862384782374');// '92734897238947920140235368219846586723251092131755157607724767170532511411462984747594595307150010826510991118633540661438116724725716707216868396687531288471883686232066348' 大整数乘法大整数加法的JavaScript实现和大整数乘法的JavaScript实现是我在两次面试中碰到的问题。大整数加法的算法我找到了上面的算法，各种奇淫技巧，简单得不行。大整数乘法呢我没有找到满意的算法，先把自己写的贴上来吧。 1234567891011121314151617181920212223242526272829// 方法var bigNumStringMultiply = (a, b) =&gt; &#123; let arra = a.split('').reverse(), arrb = b.split('').reverse(), lena = arra.length, lenb = arrb.length, result = Array(lena + lenb + 1).join('0').split(''); arra.map((itema, indexa) =&gt; &#123; arrb.map((itemb, indexb) =&gt; &#123; result[indexa + indexb] = +result[indexa + indexb] + itema * itemb; &#125;); &#125;); result.map((item, index) =&gt; &#123; if (item &gt;= 10) &#123; result[index + 1] = ~~result[index + 1] + ~~(result[index] / 10); result[index] %= 10; &#125; &#125;); return result.reverse().join('').replace(/^0+/, '');&#125;// 测试bigNumStringMultiply('87683997878946347862738468726348289374972938479823749872938479234923846237672364732478237492394738748273948789237487238472389478923748782364723647823847283974', '92734897238947832456237489273498723984782365783465782634786287346782638472983749823748357634785278348273498723894792387489327487238478234827389472938748923748235862384782374');// '8131366532804209271848777343148089734867540084740313073714626072147803459519225889924153683477346079879903114543791258684883828524130882115379440144725160920757443592354053118047908949159167193991569423470425543890534108742857689635336451466135028613346191424578161286549581455047710048500852396172271754236155746244567328967874276']]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>algorithm</tag>
        <tag>大整数加法</tag>
        <tag>大整数乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript、jQuery、算法相关的面试题]]></title>
    <url>%2F2017%2F03%2F21%2FJavaScript%E3%80%81jQuery%E3%80%81%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是一次电话面试加远程QQ监督机试。 电话面试问题： 一些我答对了的简单问题就不列出来了 快速排序怎么实现的？算法复杂度？用的什么思想？是稳定排序还是非稳定排序？ jQuery中自定义事件的实现原理？(bind, trigger) 如何处理过多的回调嵌套？Promise的实现原理？ 请描述三次握手和四次挥手。 快速排序怎么实现的？算法复杂度？用的什么思想？是稳定排序还是非稳定排序？快速排序的的JavaScript实现如下： 123456789101112131415161718192021var quickSort = (arr) =&gt; &#123; if (arr.length &lt;= 1) return arr; let pivotIndex = ~~(arr.length/2), pivot = arr.splice(pivotIndex, 1)[0], left = [], right = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 快速排序的时间复杂度平均为O(n*log(n))，最差的情况为O(n^2)。采用的是分治的思想。是非稳定排序。 jQuery中自定义事件的实现原理？(bind, trigger)机试问题： 写一个函数，实现大整数的加法。 每次走1级或者2级阶梯，走到第n级阶梯的方式有多少种？请运用动态规划的思想。 写一个函数，实现大整数的加法。我的答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var add = (a, b) =&gt; &#123; if (a.length === 0 || b.length === 0) return; if (parseInt(a) &lt; 0 || parseInt(b) &lt; 0) return; if (parseInt(a) === 0 &amp;&amp; parseInt(b) === 0) return '0'; var string2Array = (str) =&gt; str.split(''); var arrA = string2Array(a), arrB = string2Array(b); var lenA = arrA.length, lenB = arrB.length; if (lenA &gt; lenB) &#123; arrB = Array(lenA - lenB + 1).join('0').split('').concat(arrB); &#125; else if (lenA &lt; lenB) &#123; arrA = Array(lenB - lenA + 1).join('0').split('').concat(arrA); &#125; var tempArr = arrA.map((item, index) =&gt; parseInt(item) + parseInt(arrB[index])); var i = tempArr.length - 1; while (i &gt;= 0) &#123; let currentVal = tempArr[i].toString(); if (currentVal &gt;= 10) &#123; tempArr[i] = currentVal.substr(1); if (i === 0) &#123; tempArr.unshift(currentVal.substr(0, 1)); break; &#125; tempArr[i-1] = parseInt(tempArr[i - 1]) + parseInt(currentVal.substr(0, 1)); &#125; else &#123; tempArr[i] = currentVal.toString(); &#125; i--; &#125; var result = tempArr.join('').replace(/^0+/, ''); return result;&#125;; 这个答案还是我第二次才写出来的，但是提交之后明显被鄙视了。面试官的回答就是，你既然用了parseInt,为什么不直接来个 1var add = (a, b) =&gt; parseInt(a) + parseInt(b); 就好了？ 我表示很无语，但又无法反驳。面试肯定挂了，但是我还是不放弃追求真理的决心，我去网上找最优解，结果真的吓到我了。请看代码： 12345678910111213141516171819var sumOfString = (a, b) =&gt; &#123; let result = '', tempVal = 0, arra = a.split(''), arrb = b.split(''); while (arra.length || arrb.length || tempVal) &#123; tempVal += ~~arra.pop() + ~~arrb.pop(); result = tempVal % 10 + result; tempVal = tempVal &gt; 9; &#125; return result.replace(/^0+/, '');&#125;; 简单到不能忍。里面的技巧打死也想不到： arra.length || arrb.length || tempVal: 巧妙的循环边界条件 ~~arra.pop(): 把字符串转换成数字并取整 tempVal = tempVal &gt; 9: 如果=右边的判断正确，则tempVal的值为true，下次循环进入第一步计算的时候又会转换成1，从而实现进位。同样可以解释为false的情况。 每次走1级或者2级阶梯，走到第n级阶梯的方式有多少种？请运用动态规划的思想。实现方式如下： 1234567891011var methodsToStepN(n) &#123; if (n &lt;= 0) return 0; if (n === 1) return 1; if (n === 2) return 2; return methodToStepN(n - 1) + methodToStepN(n - 2);&#125;;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Promise</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发聚合、分享、期刊订阅类网站]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%81%9A%E5%90%88%E3%80%81%E5%88%86%E4%BA%AB%E3%80%81%E6%9C%9F%E5%88%8A%E8%AE%A2%E9%98%85%E7%B1%BB%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[本文转载自WEB前端开发 JavaScript Weekly一个总结JavaScript新闻和文章的免费电子邮件周刊。 掘金一个只有高手分享的社区，无论是程序员、设计师还是产品经理，都可以在这里找到相关领域的高质量内容。 CSS Weekly一个概述最新的CSS文章、教程、工具和试验的免费电子周刊。 奇舞周刊360前端，奇舞团博客整理的前端周刊，内容比较丰富，涵盖最新中文前端技术原创和翻译文章以及最新资讯。 Echo JSEcho JS 是一个社区驱动的新闻网站，专注于JavaScript开发，HTML5和前端新闻。 FEX 技术周刊百度FEX整理的技术周刊，同时推荐中英文文章，内容很多很全。 Web Designer News是为WEB开发者和设计师提供一个发现最新和最重要的WEB相关消息的地方，用户贡献的内容需要网站管理员批准才能发布。 众成翻译每周精选国外优秀文章的翻译。 开发者头条开发者头条内容很多，部分是机器人抓的，所以质量不好说。 Front-end Front许多前端文章feed。 FrontEnd Focus每周推送一次的最佳前端新闻、文章和教程。 DDFE技术周刊滴滴出行公共前端团队。 JSK Weekly做你邮箱中最好的JavaScript时事资讯。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript、CSS、HTTP知识相关的面试题]]></title>
    <url>%2F2017%2F03%2F03%2FJavaScript%E3%80%81CSS%E3%80%81HTTP%E7%9F%A5%E8%AF%86%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一上来就是前端技术人员的面试，让我感觉压力好大，有点紧张。 问题： Array有哪些方法？ 如何封装简单模块？ CSS如何实现一份设计稿完美兼容各种移动端？ CSS如何做三列布局？ CSS如何实现元素垂直水平居中？ HTTP请求的头部信息包括哪些东西？ HTTP请求的状态码有哪些，分别代表什么意思？ Node.js有哪些核心插件或模块？ 拿到一份设计稿，如何开始开发工作？ 有没有写过一些可复用的组件？ 从前端的角度考虑安全性，该如何有效预防？ 面试时确实有一部分原因是紧张，有一部分原因是基础确实不够扎实。 现在就来慢慢研究这些问题。 Array有哪些方法？ 方法名称 描述 concat 连接2个或更多数组，并返回结果 every 对数组每一项运行给定函数，如果该函数每一项都返回true，则返回true filter 对数组每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 对数组每一项运行给定函数。这个函数没有返回值 join 将所有的数组元素连成一个字符串 indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则放回-1 lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里的最大值 map 对数组的每一项运行给定函数，返回每次函数的调用结果组成的数组 reverse 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个元素 slice 传入索引值，将数组里对应索引范围内的元素作为新数组返回 some 对数组的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 push 将传入的参数作为数组的最后一项添加到数组中，并返回新数组的长度 pop 取出数组的最后一项并作为返回值 shift 取出数组的第一项并作为返回值 unshift 将传入的参数作为数组的第一项添加到数组中，并返回新数组的长度 这是我能想到和找到的所有方法了，如果看官发现更多，请提醒我，谢谢！ 如何封装简单模块？我采用的是宽放大模式，就是一个立即执行函数表达式： 12345678(function (window, module, undefined) &#123; module.sayHello = function () &#123; console.log('Hello'); &#125;; ...&#125;)(window, window.module || (window.module = &#123;&#125;)); CSS如何实现一份设计稿完美兼容各种移动端？采用rem方式，并且采用js动态识别屏幕的宽度动态生成viewport的meta标签。 CSS如何做三列布局？CSS如何实现元素水平垂直居中？ 方法一： HTML部分如下： 123&lt;div class="wrapper"&gt; &lt;div class="content"&gt;Content here&lt;/div&gt;&lt;/div&gt; CSS部分如下： 1234567891011.wrapper &#123; float: left; height: 50%; margin-bottom: -120px;&#125;.content &#123; clear: both; height: 240px; position: relative;&#125; 方法二： HTTP请求的头部信息包括哪些东西？最基本的信息如下表： 请求头部信息： 字段名 描述 举例 Host 服务器域名 Host: www.baidu.com Accept 可接受的媒体类型 Accept: * / * Accept-Encoding 可接受的编码类型 Accept-Encoding: gzip, deflate, sdch Accept-Language 可接受的语言 Accept-Language: en-US, en; q=0.8 User-Agent 用户代理 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 Content-type 发送内容类型 Content-type: text/plain Content-length 发送内容长度 Content-length: 327 Connection 客户端连接的类型 Connection: keep-alive Referer 当前文档的URL Referer: http://www.baidu.com/12345 响应头部信息： 字段名 描述 举例 Access-Control-Allow-Origin 可跨域访问源 Access-Control-Allow-Origin: * Cache-Control 可缓存性 Cache-Control: no-cache Content-length 响应内容长度 Content-length: 35 Content-type 响应内容类型 Content-type: image/gif Date 响应时间 Date: Mon, 06 Mar 2017 15:34:16 GMT Status 响应状态码 Status: 200 HTTP请求的状态码有哪些？分别代表什么意思？状态码分类： 整体范围 已定义范围 分类 100 ～ 199 100 ～ 101 信息提示 200 ～ 299 200 ～ 206 成功提示 300 ～ 399 300 ～ 307 重定向 400 ～ 499 400 ～ 417 客户端错误 500 ～ 599 500 ～ 505 服务器错误 状态码解释： 状态码 解释 100 Continue（继续） 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 Switching Protocols（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。（HTTP 1.1新） 200 OK（成功） 一切正常，对GET和POST请求的应答文档跟在后面。 201 Created（已创建）服务器已经创建了文档，Location头给出了它的URL。 202 Accepted（已接受）服务器已接受了请求，但尚未对其进行处理。 203 Non-Authoritative Information（非授权信息）文档已经正常地返回，但一些应答头可能不正确，可能来自另一来源 。（HTTP 1.1新）。 204 No Content（无内容）未返回任何内容，浏览器应该继续显示原来的文档。 205 Reset Content（重置内容）没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 Partial Content（部分内容）服务器成功处理了部分 GET 请求。（HTTP 1.1新） 300 Multiple Choices（多种选择）客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently（永久移动）请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 Found（临时移动）类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”，出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 See Other（查看其他位置）类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 Not Modified（未修改）自从上次请求后，请求的网页未被修改过。原来缓冲的文档还可以继续使用，不会返回网页内容。 305 Use Proxy（使用代理）只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。（HTTP 1.1新） 307 Temporary Redirect（临时重定向）和 302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新） 400 Bad Request（错误请求）请求出现语法错误。 401 Unauthorized（未授权）客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。 403 Forbidden（已禁止） 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found（未找到）无法找到指定位置的资源。 405 Method Not Allowed（方法禁用）请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）禁用。（HTTP 1.1新） 406 Not Acceptable（不接受）指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新） 407 Proxy Authentication Required（需要代理授权）类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 Request Time-out（请求超时）服务器等候请求时超时。（HTTP 1.1新） 409 Conflict（冲突）通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 Gone（已删除）如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。（HTTP 1.1新） 411 Length Required（需要有效长度）不会接受包含无效内容长度标头字段的请求。（HTTP 1.1新） 412 Precondition Failed（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。（HTTP 1.1新） 413 Request Entity Too Large（请求实体过大）请求实体过大，已超出服务器的处理能力。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头。（HTTP 1.1新） 414 Request-URI Too Large（请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法进行处理。 415 Unsupported Media Type（不支持的媒体类型）请求的格式不受请求页面的支持。 416 Requested range not satisfiable（请求范围不符合要求）服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 417 Expectation Failed（未满足期望值）服务器未满足”期望”请求标头字段的要求。 500 Internal Server Error（服务器内部错误）服务器遇到错误，无法完成请求。 501 Not Implemented（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 502 Bad Gateway（错误网关）服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable（服务不可用）服务器由于维护或者负载过重未能应答。通常，这只是一种暂时的状态。 504 Gateway Time-out（网关超时） 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 505 HTTP Version not supported（HTTP 版本不受支持）不支持请求中所使用的 HTTP 协议版本。 Node.js有哪些核心插件或模块？Node.js核心模块如下表： 模块名称 描述 http 提供http服务器功能 url 用于解析url fs 文件IO系统 querystring 解析url的查询字符串 util 提供实用工具 path 处理文件路径 crypto 提供加密解密功能 child_process 新建子进程 为了提高运行速度，上面这些核心模块在安装时都会被编译成二进制文件。 拿到一份设计稿，如何开始开发工作？先分析布局，划分框架，然后规划结构，编写代码。 如果是协同开发，那就要建立代码规范： 合理地使用标签 准确使用CSS 良好的注释 清晰的代码结构 除此之外，为了提高效率，降低出错率，应该实现前端工程化。 有没有写过一些可复用的组件？从前端的角度考虑安全性，该如何有效预防？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次关于前端领域知识的面试]]></title>
    <url>%2F2017%2F03%2F03%2F%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86%E7%9A%84%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[离家很近的一家初创型公司，技术面试官是CTO，做后台的。 技术面试官问我的问题： 用过什么框架，开发过什么东西？ 能不能实现一套代码，同时兼容PC端和平板端？ 混合应用，小程序，微信开发平台。 其他的不记得了。 由于对方不是做前端的，因此并没有问到JS和CSS等基础性问题。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将代码同时push到两个不同的远程仓库]]></title>
    <url>%2F2017%2F03%2F03%2F%E5%B0%86%E4%BB%A3%E7%A0%81%E5%90%8C%E6%97%B6push%E5%88%B0%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[为何要将代码push到两个仓库我自己的博客，本来是放在github托管的。但是大家都知道，github在国内访问速度不好，有时候甚至无法访问。因此我就想同时在coding上也放一份，这样就可以实现在国内正常流畅地访问了。 方法简单地说，就是在git的config文件中remote下面增加一个远程仓库地址。添加方式有两种： 直接修改.git文件夹下面的config文件，找到[remote &#39;origin&#39;]，在下面增加一行，输入想要增加的远程仓库的地址。示例效果如下： 1234[remote &quot;origin&quot;] url = git@github.com:ricosmall/ricosmall.github.io.git url = git@git.coding.net:ricosmall/ricosmall.coding.me.git 用命令行的方式添加： 默认无远程仓库地址设置的情况下，添加第一个仓库地址： 1git remote add origin git@github.com:ricosmall/ricosmall.github.io.git 再添加第二个仓库地址： 1git remote add origin git@git.coding.net:ricosmall/ricosmall.coding.me.git 这样就算完成了。 之后你再push代码的时候，和往常一样： 1git push origin master 就可以了。 总结之前一直没有试过去找方法，采取的方式就是push到一个仓库之后，删掉remote.url。然后再重新添加另一个仓库地址，再push一次。真是麻烦到没朋友，还容易导致两边的代码不同步。有了这个方法，一切都解决了。你试试吧。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试遇到的简单CSS问题]]></title>
    <url>%2F2017%2F03%2F02%2F%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E7%AE%80%E5%8D%95CSS%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[为什么要找工作出来工作已经将近4年时间，一开始没能给自己制定清晰的职业规划，导致工作到现在，有大半的时间纯属浪费生命。现在定好了目标，就只要衡量自己目前是离目标是越来越远还是越来越近。我判断我自己的情况，明显离目标越来越远。所以需要作出调整，再找工作吧。 面试总结技术面试官问我的问题： 1.描述css的优先级顺序。（浏览器自带的样式，开发者定义的样式，用户定义的样式） 我的回答是：用户样式 &gt; 开发者样式 &gt; 浏览器样式。如果看官发现不对，还请指正。 2.对css中绝对定位和相对定位的理解。 我的回答是： 绝对定位：如果父元素有定位属性，则绝对定位以父元素为参照；如果没有，则一直上溯到有定位属性的元素，并以其为参照。 相对定位：相对于自己本来应该在的位置而言的。 3.对块级元素和行内元素的理解。 我的回答是： 行内元素一般位于块级元素中，一般用于内容展示。（真不知道怎么回答合适） 4.问一个流程图制作web应用的实现方式。（我的理解就是要做一个类似processOn的产品） 我的回答是： 分成两个大模块，一个面板，一个工作空间。面板包括各种小组件，工作空间包括各种样式调整功能和编辑功能。用纯js即可实现。 我感觉表达能力弱爆了，当然架构也弱。 继续学习。 如果有看官看到了此文，还请稍微指教一下小弟。不胜感激！]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript内置对象]]></title>
    <url>%2F2016%2F07%2F24%2FJavascript%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是对象JavaScript中的所有事物都是对象，如：字符串、数值、数组、函数等，每个对象带有属性和方法。 对象的属性 定义：反映该对象某些特定的性质的。如：字符串的长度、图像的长宽等 访问对象属性：objectName.propertyName 对象的方法 定义：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等 访问对象的方法：objectName.methodName() Date对象Date对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。 定义一个时间对象：var myDate=new Date(); Date对象中处理时间和日期的常用方法： 方法名称 功能 get/setDate() 返回/设置日期(1 ~ 31) get/setFullYear() 返回/设置年份，用四位数表示 get/setYear() 返回/设置年份 get/setMonth() 返回/设置月份(0 ~ 11) get/setDay() 返回/设置星期(0 ~ 6) get/setHours() 返回/设置小时(0 ~ 23) get/setMinutes() 返回/设置分钟(0 ~ 59) get/setSeconds() 返回/设置秒钟(0 ~ 59) get/setMilliSeconds() 返回/设置毫秒(0 ~ 999) get/setTime() 返回/设置时间(毫秒) String字符串对象 Array数组对象的部分方法 返回指定位置的字符 stringObject.charAt(index) index：必需。表示字符串中某个位置的数字(字符在字符串中的下标)。 返回指定的字符串首次出现的位置 stringObject.indexOf(substring, startpos) substring：必需。需要检索的字符串值。 startpos：可选。整数，表示字符开始检索的位置，取值范围为0到stringObject.length-1。如省略此参数，则从被检索字符串首字符开始检索。 字符串分割 stringObject.split(separator,limit) separator：必需。表示从该参数指定的位置分割stringObject。 limit：可选。表示分割的次数，如设置该参数，返回的子串数量不会多于该参数。 提取字符串 stringObject.substring(starPos,stopPos) starPos：必需。一个非负的整数，表示开始位置。 stopPos：可选。一个非负的整数，表示结束位置，如省略该参数，返回的子串一直到stringObject的结尾。 提取指定书目字符串 stringObject.substr(startPos,length) starPos：必需。一个非负的整数，表示开始位置。 length：可选。一个非负的整数，表示提取字符串的长度，如省略该参数，返回的子串一直到stringObject的结尾。 Math对象Math对象，提供对数据的数学计算。Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 Math对象的部分属性 属性 说明 Math.E 返回算术常量e，即自然对数的底数(约2.718) Math.PI 返回圆周率(约3.14159) Math对象的部分方法 向上取整Math.ceil(x)x：必需。必须是一个数值。 向下取整Math.floor(x)x：必需。必须是一个数值。 四舍五入Math.round(x)x：必需。必须是一个数值。 随机数Math.random();返回一个大于或等于0但小于1的符号为正的数字值。 Array数组对象数组对象是一个对象的集合，里边的对象可以是不同类型的。数组的每一个成员对象都有一个“下标”，用来表示它在数组中的位置，是从0开始的。 Array数组对象的部分方法 数组连接arrayObject.concat(array1,array2,...,arrayN)该方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 指定分隔符连接数组元素arrayObject.join(separator)separator：可选。表示要使用的分隔符，如果省略该参数，则使用逗号作为分隔符。 颠倒数组元素顺序arrayObject.reverse()该方法会改变原来的数组，而不会创建新的数组。 选定元素arrayObject.slice(start,end)start：必需。规定从何处开始选取，如果是负数，那么它规定的是从数组尾部开始算起的元素。-1指最后一个元素，-2指倒数第二个元素。end：可选。规定从何处结束选取，如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 数组排序arrayObject.sort(方法函数)方法函数：可选。规定排序顺序，必须是函数。如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo搭建博客]]></title>
    <url>%2F2016%2F07%2F02%2F%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[为什么从Jekyll搬到hexo来之前专门用了两天时间来捣鼓Jekyll，但是最后还是没达到想要的效果。中间就没有去管了。但是现在又萌生了搭建博客的想法，继续爬贴找教程，终于发现了hexo。 Jekyll和hexo一样，都可以很大程度地自定义，但是以我粗浅的理解，hexo的自动化程度更高一些。根据大神们的使用心得能够看得出来，很多东西都可以自动生成，而且配置相当简答。究竟哪些方面让人爱不释手，等我用过一段时间再来分享吧。 用github-pages和hexo搭建博客我就是按照大神写的教程一步一步操作的，一次成功，就连碰到的bug都在大神的预料之中。在此直接引用大神sunwhut的教程供大家参考： 如何利用GitHub Pages和Hexo快速搭建个人博客 主题我上次在搭建Jekyll博客的时候，在找教程的过程中就发现了让人眼前一亮的博客主题，名字叫做NexT。上面给的这个教程的作者采用的也是这个主题，真是棒极了。主题的作者iissnan说的精于心，简于形用来形容这个主题很恰当。 评论以及第三方功能评论推荐多说，很好用。hexo上面有非常详细的介绍。 配置文件hexo的配置文件分为站点配置文件和主题配置文件，搭配使用可以让博客容光焕发，异常强大。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github-pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F04%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
